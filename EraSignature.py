import pandas as pd
import numpy as np

# This is broken, and I am not sure why. there are some signatures taht are only a few, 19,21,20 longer than they should be and I dont' know why.


class EraToSignature:
  """
      A class that stores the methods to derive a signature from a Era
      You should add a method to make sure that the order and contents of ORTHODOX_FEATURE_PAIRS is the same.
      So you can compare two signatures to see if they were geneated by the same code.

      # only implement this if you need to. I think if you are storing the round signatures.
  """

  def __init__(self, ORTHODOX_FEATURE_PAIRS: pd.DataFrame):
    """
      The constructor EraToSignature that stores the ORTHODOX_FEATURE_PAIRS and FEATURE_NAMES. 
      ORTHODOX_FEATURE_PAIRS: a pd.Dataframe where col f1: is a feature_name and col f2: is a feature name.

      Typically this is read from your google drive via:
      
        ORTHODOX_FEATURE_PAIRS = pd.read_csv('/content/drive/MyDrive/othodox_feature_pairs.csv')
    """

    #{(0, 0), (0, 1), (0, 2), ... (4,3), (4,4)} as a set, is a Constant
    self.VALID_FEATURE_PERMUTES = set([(a,b) for a in range(5) for b in range(5)])
    self.ORTHODOX_FEATURE_PAIRS = ORTHODOX_FEATURE_PAIRS

             
  def _create_empty_era_signature_df(self, ) -> pd.DataFrame:
    """
        Creates an empty era_signature_df based on the VALID_FEATURE_PERMUTES and ORTHODOX_FEATURE_PAIRS in memory
    """
    ordered_valid_feature_permutes = sorted([str(s[0]) + ',' + str(s[1]) for s in self.VALID_FEATURE_PERMUTES])
    empty_era_signature_df = pd.DataFrame(data=None, columns=ordered_valid_feature_permutes)
    empty_era_signature_df = self._add_multi_index(empty_era_signature_df)
    return empty_era_signature_df


  def _add_multi_index(self, empty_era_signature_df:pd.DataFrame) -> pd.DataFrame:
    """ 
      Add the multi index of the feature names to the empty empty_era_signature_df
      Only called by _create_empty_era_signature_df 
    """
    f1 = []
    f2 = []
    for row in self.ORTHODOX_FEATURE_PAIRS.values: 
      f1.append(row[0])
      f2.append(row[1])

    empty_era_signature_df['f1'] = f1
    empty_era_signature_df['f2'] = f2
    return empty_era_signature_df.set_index(['f1', 'f2'])


  def _compute_feature_combination_value_counts(self, era_df:pd.DataFrame, col1:str, col2:str) -> pd.DataFrame:
    """
        Compute the normalized pd.value_counts() for each combination of of possible values of col1 and col2 within era_df
        Returns a DataFrame of the normed value counts of col1 and col2
        :params: 
          era_df: pd.Dataframe | a subset of the numerai data corrosponding to a single era. Generated by era_df = train_df[train_df['era']==2]
          col1: str | the name of feature column within era_df
          col2: str | the name of feature column within era_df, must be different from col2. 
    """
    normalized_value_counts_df = era_df[[col1,col2]].value_counts(normalize=True) # this is the dominating time cost.
    # I have not tested if it would be faster to pass this function 2 arrays and do value counts on those.


    if normalized_value_counts_df.shape[0]>25:
      current_era = list(era_df['era'].unique())[0]

      print(normalized_value_counts_df)
      ValueError(f"You are at{col1} , {col2} in {current_era} and you have a signature that is greater than 25 long")

    if normalized_value_counts_df.shape[0] == 25: # early stopping
      normalized_value_counts_df.sort_index(axis=0, inplace=True) # Every value normalized_value_counts_df is returned with this order
      return normalized_value_counts_df
    else:
      normalized_value_counts_df = self._add_missing_permutes(normalized_value_counts_df)
      return normalized_value_counts_df

    # Suspect
  def _add_missing_permutes(self, normalized_value_counts_df):
    """ 
      Add zeros in normalized_value_counts_df for missing permutes.
      Only called by compute_feature_combination_value_counts() 
    """
    # missing permutes are the combinations that are missing from value counts because there are no instances for those. 
    # eg if ther are no instances of [3,4] then this will assign that value to be 0.0
    missing_permutes = list(self.VALID_FEATURE_PERMUTES -  set(normalized_value_counts_df.index)) 

    for permute in missing_permutes:
      normalized_value_counts_df[permute[0], permute[1]] = 0.0 

    normalized_value_counts_df.sort_index(axis=0, inplace=True)
    return normalized_value_counts_df

   
  def derive_era_signature(self, era_df: pd.DataFrame) -> pd.DataFrame:
    """
        Create a normalized values counts signature of era_df. 
        Only method to be called outside the class
        Uses the internal attributes for self.VALID_FEATURE_PERMUTES and self.ORTHO
    """
    era_signature = self._create_empty_era_signature_df()

    for row_index in range(era_signature.shape[0]):
      feature_name1, feature_name2 = era_signature.index[row_index] 
      ordered_norm_val_counts = self._compute_feature_combination_value_counts(era_df, feature_name1, feature_name2).values
      era_signature.loc[(feature_name1,feature_name2), era_signature.columns] = ordered_norm_val_counts

    era_sig_as_array = era_signature.values.flatten().astype(np.float32) # untested
    return era_sig_as_array
